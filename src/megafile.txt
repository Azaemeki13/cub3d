/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   color.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 10:47:16 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/21 16:10:44 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int create_rgb_color(int r, int g, int b)
{
    return (r << 16 | g << 8 | b);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   doors.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 16:14:23 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 14:12:35 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	init_cell(t_game *g, int i, int x, int y)
{
	t_door	*d;
	char	c;

	d = &g->doors[i];
	d->frac = 0.0;
	d->target = 0;
	d->active = 0;
	c = g->map->map[y][x];
	if (c == 'D')
		d->active = 1;
	else if (c == 'd')
	{
		d->active = 1;
		d->frac = 1.0;
		d->target = 1;
		g->map->map[y][x] = 'D';
	}
}

void doors_init(t_game *game)
{
    int i;
    int x;
    int y;
    
    i = 0;
    game->doors = malloc(sizeof(t_door) * (game->map->map_height) * (game->map->map_width));
    y = 0;
    while (y < game->map->map_height)
    {
        x = 0;
        while (x < game->map->map_width)
            init_cell(game, i++, x++, y);
        y++;
    }
    game->door_speed = 1.8;
}

t_door *door_at(t_game *game, int x, int y)
{
    int w;
    int h;
    
    w = game->map->map_width;
    h = game->map->map_height;
    if (x < 0 || y < 0 || x >= w || y >=h)
        return (NULL);
    return(&game->doors[y * w + x]);
}

 void doors_update(t_game *game, double dt)
 {
    int i;
    int n;
    double step;
    t_door *door;

    n = game->map->map_width * game->map->map_height;
    if (dt > 0.0)
        step = game->door_speed * dt;
    else
        step = 0.03;
    i = 0;
    while(i < n)
    {
        door = &game->doors[i++];
        if (!door->active)
            continue;
        if (door->target && door->frac < 1.0)
        {
            door->frac += step;
            if (door->frac > 1.0)
                door->frac = 1.0;
        }
        else if (!door->target && door->frac > 0.0)
        {
            door->frac  -= step;
            if (door->frac < 0.0)
                door->frac = 0.0;
        }
    }
 }
 
void door_toggle_at(t_game *game, int x, int y)
{
    t_door *door;
    int px;
    int py;

    door = door_at( game, x, y);
    if (!door)
        return;
    px = (int)game->player->player_pos->x;
    py = (int)game->player->player_pos->y;
    if (door->target && door->frac > 0.5)
    {
        if (!(px == x && py == y))
            door->target = 0;

    }
    else
        door->target = 1;
}

static bool is_door_valid(char **map, int x, int y, int map_width, int map_height)
{
    if (x <= 0 || x >= map_width - 1 || y <= 0 || y >= map_height - 1)
        return false;
    bool horizontal_walls = (map[y][x - 1] == '1' && map[y][x + 1] == '1');
    bool vertical_walls = (map[y - 1][x] == '1' && map[y + 1][x] == '1');
    return (horizontal_walls && !vertical_walls) || (!horizontal_walls && vertical_walls);
}

void validate_doors(t_game **game)
{
    char **map = (*game)->map->map;
    int x, y;
    
    y = 0;
    while (y < (*game)->map->map_height)
    {
        x = 0;
        while (x < (*game)->map->map_width)
        {
            if (map[y][x] == 'D' || map[y][x] == 'd')
            {
                if (!is_door_valid(map, x, y, (*game)->map->map_width, (*game)->map->map_height))
                {
                    error_msg("Door not properly placed between walls.");
                    free_game(game);
                    exit(EXIT_FAILURE);
                }
            }
            x++;
        }
        y++;
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_management.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 12:52:22 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/04 13:24:03 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void error_msg(const char *msg)
{
        write(2, "Error\n", 6);
        write (2, msg, ft_strlen(msg));
        write(2, "\n", 1);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialisation.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 14:23:36 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 14:26:25 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"


void init_struct(t_game **game, char *path)
{
    *game = malloc(sizeof(**game));
    ft_memset(*game, 0, sizeof(*game));
    (*game)->mlx = mlx_init();
    (*game)->map = malloc(sizeof(t_map));
    ft_memset((*game)->map, 0, sizeof(t_map));
    malloc_texture(game);
    init_map(game, path);
    init_player(game);
    doors_init(*game);
    (*game)->buttons.w = 0;
    (*game)->buttons.s = 0;
    (*game)->buttons.q = 0;
    (*game)->buttons.d = 0;
    (*game)->buttons.rotate_left = 0;
    (*game)->buttons.rotate_right = 0;
    (*game)->game_pause = 0;
    (*game)->show_minimap = 1;
    (*game)->mouse_sens = 0.0008;
    (*game)->last_mouse_x = WIN_WIDTH / 2;
    (*game)->hit_tile = 0;
    (*game)->side_out = 0;
    (*game)->wall_x = 0.0;
    (*game)->ray_dir.x = 0.0;
    (*game)->ray_dir.y = 0.0;
    (*game)->img = NULL;
    (*game)->addr = NULL;
    (*game)->bits_per_pixel = 0;
    (*game)->line_length = 0;
    (*game)->endian = 0;
}

int count_lines(char *path)
{
    int fd;
    int result;
    char *line;

    result = 0;
    fd = open(path, O_RDONLY);
    if (fd < 0)
        return (0);
    while ((line = get_next_line(fd)) != NULL)
    {
        free(line);
        result++;
    }
    close(fd);
    return(result);
}

int map_details(char *line)
{
    int i;
    
    i = 0;
    if (!line)
        return(0);
    while(line[i] && ft_isspace(line[i]))
        i++;
    if (line[i] && line[i] == '1')
        return (1);
    else
        return(0);
}

void validate_all_textures_present(t_game **game)
{
    t_map *map = (*game)->map;
    
    if (!map->no || !map->no->text_img)
    {
        error_msg("Missing NO texture path.");
        free_game(game);
        exit(1);
    }
    if (!map->so || !map->so->text_img)
    {
        error_msg("Missing SO texture path.");
        free_game(game);
        exit(1);
    }
    if (!map->ea || !map->ea->text_img)
    {
        error_msg("Missing EA texture path.");
        free_game(game);
        exit(1);
    }
    if (!map->we || !map->we->text_img)
    {
        error_msg("Missing WE texture path.");
        free_game(game);
        exit(1);
    }
    if (!map->door || !map->door->text_img)
    {
        error_msg("Missing DOOR texture path.");
        free_game(game);
        exit(1);
    }
    if (!map->ceiling)
    {
        error_msg("Missing ceiling color (C).");
        free_game(game);
        exit(1);
    }
    if (!map->floor)
    {
        error_msg("Missing floor color (F).");
        free_game(game);
        exit(1);
    }
}

void check_texture_files(t_game **game)
{
    t_map *map;
    int i;

    i = 0;
    map = (*game)->map;
    while(map->content[i])
    {
        while(!map_details(map->content[i]))
        {
            if (!ft_isblank(map->content[i]))
                validate_textures(map->content[i], game);
            i++;
        }
        while(ft_isblank(map->content[i]))
            i++;
        if (!map_details(map->content[i]))
            error_msg("Line not blank and map incorrect.");
        map_pointer(game, i);
        while(map_details(map->content[i]) && map->content[i])
            line_checker(map->content[i++], game);
        break;
    }
    validate_all_textures_present(game);
}

void init_map(t_game **game, char *path)
{
    t_map *map;
    int fd;
    int i;
    int count;

    i = 0;
    map = (*game)->map;
    count = count_lines(path);
    if (count == 0)
    {
        error_msg("Cannot open file / File empty.");
        free_game(game);
        exit(1);
    }
    fd = open(path, O_RDONLY);
    map->content = malloc(sizeof(char *) * (count + 1));
    map->content[count] = NULL;
    map->height = 200;
    map->width = 200;
    while(i != count)
        map->content[i++] = get_next_line(fd);
    check_texture_files(game);
    calculate_map_size(game);
    validate_doors(game);
    validate_player_count(game); // Add this line
    (*game)->mouse_sens = 0.0008;
    (*game)->last_mouse_x = WIN_WIDTH / 2;
    close(fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialisation_map.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 13:49:34 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 16:18:55 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

void	is_begin(char *line, t_game **game, bool *begin)
{
	char	*p;

	p = line;
	if (!*begin)
	{
		while (ft_isspace(*p))
			p++;
		while (*p == '1' || ft_isspace(*p))
			p++;
		if (*p != '\n')
		{
			error_msg("map not valid.");
			free_game(game);
			exit(EXIT_FAILURE);
		}
		*begin = true;
	}
}

void	is_end(char *line, t_game **game, bool *end, bool *begin)
{
	char	*p;

	p = line;
	if (*begin && !*end)
	{
		while (ft_isspace(*p))
			p++;
		while (*p == '1' || ft_isspace(*p))
			p++;
		if (!ft_isblank(p))
		{
			error_msg("map not valid.");
			free_game(game);
			exit(EXIT_FAILURE);
		}
		*end = true;
	}
}

int	map_char_check(char c)
{
	if (!(c == '1'
		|| c == '0'
		|| c == 'N'
		|| c == 'S'
		|| c == 'E'
		|| c == 'W'
		|| c == 'D'
		|| ft_isspace(c)))
		return (0);
	return (1);
}

void	line_checker(char *map_line, t_game **game)
{
    static bool	begin   = false;
    static bool	end     = false;
    int			i;

    is_begin(map_line, game, &begin);
    i = 0;
    while (map_line[i])
    {
        if (!map_char_check(map_line[i]) && map_line[i] != '\n')
        {
            error_msg("Unauthorized character in map.");
            free_game(game);
            exit(EXIT_FAILURE);
        }
        i++;
    }
    is_end(map_line, game, &end, &begin);
}

void validate_player_count(t_game **game)
{
    char **map = (*game)->map->map;
    int player_count = 0;
    int x, y;
    
    y = 0;
    while (y < (*game)->map->map_height)
    {
        x = 0;
        while (x < (*game)->map->map_width && map[y][x])
        {
            if (ft_strchr("NSEW", map[y][x]))
                player_count++;
            x++;
        }
        y++;
    }
    
    if (player_count == 0)
    {
        error_msg("No player start position found in map.");
        free_game(game);
        exit(EXIT_FAILURE);
    }
    else if (player_count > 1)
    {
        error_msg("Multiple player start positions found in map.");
        free_game(game);
        exit(EXIT_FAILURE);
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialisation_utils2.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 10:36:40 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 12:54:30 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

void extension_validator(char *str, t_game **game)
{
    char *extension;

    extension = ft_strrchr(str, '.');
    if (!extension)
    {
        error_msg("Wrong extension.");
        free_game(game);
        exit(1);
    }
    if ((ft_strncmp(extension, ".xpm", 4) != 0) && (!ft_isblank(str + 4)))
    {
        error_msg("Wrong extension || Line after expansion not blank.");
        free_game(game);
        exit(1);
    }
}

void case_texture_helper(t_game **game, int option, char *str)
{
    char *nav = NULL; 
    t_map *map;
    t_text *text;

    map = (*game)->map;
    if (option == 3)
    {
        text = map->so;
        nav = ft_strndup(str, (size_t)ft_special_len(str, ' '));
        text->text_img = mlx_xpm_file_to_image((*game)->mlx, nav, &text->width, &text->height);
        texture_error_helper(text->text_img, nav, game);
        text->addr = mlx_get_data_addr(text->text_img, &text->bpp, &text->sl, &text->end);
    } 
    if (option == 4)
    {
        text = map->we;
        nav = ft_strndup(str, (size_t)ft_special_len(str, ' '));
        text->text_img = mlx_xpm_file_to_image((*game)->mlx, nav, &text->width, &text->height);
        texture_error_helper(text->text_img, nav, game);
        text->addr = mlx_get_data_addr(text->text_img, &text->bpp, &text->sl, &text->end);
    }
    case_texture_door(game,option,str);
    if (nav)
        free(nav);
}

void case_texture_door(t_game **game, int option, char *str)
{
    char *nav = NULL; 
    t_map *map;
    t_text *text;

    map = (*game)->map;
    if (option == 7)
    {
        text = map->door;
        nav = ft_strndup(str, (size_t)ft_special_len(str, ' '));
        text->text_img = mlx_xpm_file_to_image((*game)->mlx, nav, &text->width, &text->height);
        texture_error_helper(text->text_img, nav, game);
        text->addr = mlx_get_data_addr(text->text_img, &text->bpp, &text->sl, &text->end);
    } 
    if (nav)
        free(nav);
}

void texture_error_helper(void *image, char *nav, t_game **game)
{
    if (!image)
    {
        error_msg("xpm file not found.");
        free(nav);
        free_game(game);
        exit(1); 
    }
}

void init_player(t_game **game)
{
    t_player *player;
    
    (*game)->player = malloc(sizeof(t_player));
    player = (*game)->player;
    player->player_pos = malloc(sizeof(t_vector));
    player->camera_plane = malloc(sizeof(t_vector));
    player->vector_dir = malloc(sizeof(t_vector));
    ft_memset(player->player_pos, 0, sizeof(t_vector));
    ft_memset(player->camera_plane, 0, sizeof(t_vector));
    ft_memset(player->vector_dir, 0, sizeof(t_vector));
    player->pitch = 0;
    player->orientation = 'N'; //not sure bout that one
    init_start(game); 
    init_orientation(game);
}

void map_pointer(t_game **game, int i)
{
    t_map *map;
    char **nav;
    int d;

    d = -1;
    map = (*game)->map;
    nav = map->content;
    while (++d < i)
        nav++;
    map->map = nav;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialisation_utils3.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 11:58:39 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 16:22:13 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

void rgb_error(t_game **game, char **str)
{
    error_msg("RGB format incorrect.");
    ft_free_string_array(str);
    free_game(game);
    exit(1);
}

void verify_rgb_number(t_game **game, char **verification)
{
    int i;
    char *nav;
    
    i = 0;
    while(i < 3)
    {
        nav = verification[i];
        while (*nav)
        {
            if (!ft_isdigit(*nav))
            {
                rgb_error(game, verification);
                return;
            }
            nav++;
        }
        i++;
    }
}

char **verify_syntax_rgb(t_game **game, char *str)
{
    char **verification;
    char *nav;
    int i;

    verification = ft_split(str, ',');
    if (!verification)
        rgb_error(game, verification);
    if (count_strings(verification) != 3)
        rgb_error(game, verification);
    
    i = 0;
    while (i < 3)
    {
        nav = verification[i];
        if (!nav || !*nav)
            rgb_error(game, verification);
        while (*nav && ft_isspace(*nav))
            nav++;
        if (!*nav)
            rgb_error(game, verification);
        while (*nav)
        {
            if (!ft_isdigit(*nav) && !ft_isspace(*nav) && *nav != '\n')
                rgb_error(game, verification);
            nav++;
        }
        i++;
    }
    return (verification);
}

t_rgb *add_rgb(t_game **game, char **rgb)
{
    t_rgb *result;
    char *trimmed;
    int i;

    result = malloc(sizeof(t_rgb));
    if (!result)
        rgb_error(game, rgb);
    i = 0;
    while (i < 3)
    {
        trimmed = rgb[i];
        while (*trimmed && ft_isspace(*trimmed))
            trimmed++;
        rgb[i] = trimmed;
        i++;
    }
    result->r = ft_atoi(rgb[0]);
    result->g = ft_atoi(rgb[1]);
    result->b = ft_atoi(rgb[2]);
    if (result->r > 255 || result->g > 255 || result->b > 255 ||
        result->r < 0 || result->g < 0 || result->b < 0)
    {
        free(result);
        rgb_error(game, rgb);
    }
    return (result);
}

void  malloc_texture(t_game **game)
{
    (*game)->map->no = malloc(sizeof(t_text));
    (*game)->map->door = malloc(sizeof(t_text));
    (*game)->map->ea = malloc(sizeof(t_text));
    (*game)->map->so = malloc(sizeof(t_text));
    (*game)->map->we = malloc(sizeof(t_text));
    ft_memset((*game)->map->no, 0 , sizeof(t_text));
    ft_memset((*game)->map->ea, 0 , sizeof(t_text));
    ft_memset((*game)->map->so, 0 , sizeof(t_text));
    ft_memset((*game)->map->we, 0 , sizeof(t_text));
    ft_memset((*game)->map->door, 0 , sizeof(t_text));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialisation_utils4.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 11:16:22 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 16:47:54 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int start_helper(char c)
{
    if (c == 'N' || c == 'E' || c == 'S'
    || c == 'W')
        return(1);
    return(0);
}

void set_vector(t_vector *vector, double x, double y)
{
    vector->x = x;
    vector->y = y;
}

void init_orientation(t_game **game)
{
    char orientation;
    t_vector *vector;
    t_vector *plane;

    vector = (*game)->player->vector_dir;
    plane = (*game)->player->camera_plane;
    orientation = (*game)->player->orientation;
        
    if (orientation == 'N')
    {
        set_vector(vector, 0.0, -1.0);
        set_vector(plane, 0.66, 0.0);
    }
    if (orientation == 'S')
    {
        set_vector(vector, 0.0, 1.0);
        set_vector(plane, -0.66, 0.0);
    }
    if (orientation == 'E')
    {
        set_vector(vector, 1.0, 0.0);
        set_vector(plane, 0.0, 0.66);
    }
    if (orientation == 'W')
    {
        set_vector(vector, -1.0, 0.0);
        set_vector(plane, 0.0, -0.66);
    }
}

void init_start(t_game **game)
{
    char **map;
    int i;
    int j;
    t_player *player;
    
    i = 0;
    player = (*game)->player;
    map = (*game)->map->map;
    while(map[i])
    {
        j = 0;
        while (map[i][j])
        {
            if(start_helper(map[i][j]))
            { 
                player->player_pos->x = (double)j + 0.5;  // Center in grid cell
                player->player_pos->y = (double)i + 0.5;  // Center in grid cell
                player->orientation = map[i][j];
                return;
            }
            j++;
        }
        i++;
    }
    return ;
}

void calculate_map_size(t_game **game)
{
    char **map;
    int i;
    int j;
    int max_length;
    int y;
    int len;
    int x;
    char *new_line;

    j = 0;
    max_length = 0;
    map = (*game)->map->map;
    while(map[j])
    {
        if (ft_isblank(map[j]))
            break;
        i = 0;
        while(map[j][i] && map[j][i] != '\n')
            i++;
        if (i > max_length)
            max_length = i;
        j++;
    }
    (*game)->map->map_height = j;
    (*game)->map->map_width = max_length;
    y = 0;
    while (y < j)
    {
        len = ft_strlen(map[y]);
        if (len < max_length)
        {
            new_line = ft_calloc(max_length + 1, sizeof(char));
            ft_strlcpy(new_line, map[y], len + 1);
            x = len;
            while (x < max_length)
            {
                new_line[x] = ' ';
                x++;
            }
            new_line[max_length] = '\0';
            free(map[y]);
            map[y] = new_line;
        }
        y++;
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initialisation_utils.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 09:39:16 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/19 10:51:19 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int texture_helper(char *str)
{
    if (!str)
        return (0);
    if ((ft_strncmp(str, "NO", 2) == 0) && ft_isspace(*(str+2)))
        return (1);
    else if ((ft_strncmp(str, "EA", 2) == 0) && ft_isspace(*(str+2)))
        return (2);
    else if ((ft_strncmp(str, "SO", 2) == 0) && ft_isspace(*(str+2)))
        return (3);
    else if ((ft_strncmp(str, "WE", 2) == 0) && ft_isspace(*(str+2)))
        return (4);
    else if ((ft_strncmp(str, "C", 1) == 0) && ft_isspace(*(str+1)))
        return (5);
    else if ((ft_strncmp(str, "F", 1) == 0) && ft_isspace(*(str+1)))
        return (6);
    else if ((ft_strncmp(str, "D", 1) == 0) && ft_isspace(*(str+1)))
        return (7);    
    else
        return(0);
}

void case_texture(t_game **game, int option, char *str)
{
    char *nav = NULL;
    t_map *map;
    t_text *text;
    
    map = (*game)->map;
    extension_validator(str, game);
    if (option == 1)
    {
        text = map->no;
        nav = ft_strndup(str, (size_t)ft_special_len(str, ' '));
        text->text_img = mlx_xpm_file_to_image((*game)->mlx, nav, &text->width, &text->height);
        texture_error_helper(text->text_img, nav, game);
        text->addr = mlx_get_data_addr(text->text_img, &text->bpp, &text->sl, &text->end);
    }
    if (option == 2)
    {
        text = map->ea;
        nav = ft_strndup(str, (size_t)ft_special_len(str, ' '));
        text->text_img = mlx_xpm_file_to_image((*game)->mlx, nav, &text->width, &text->height);
        texture_error_helper(text->text_img, nav, game);
        text->addr = mlx_get_data_addr(text->text_img, &text->bpp, &text->sl, &text->end);
    }
    case_texture_helper(game, option, str);
    if (nav)
        free(nav);
}

void case_rgb(t_game **game, int option, char *str)
{
    char **rgb;
    
    rgb = verify_syntax_rgb(game, str);
    if (option == 5)
        (*game)->map->ceiling = add_rgb(game, rgb);

    if (option == 6)
        (*game)->map->floor = add_rgb(game, rgb);
    ft_free_string_array(rgb);
}

void add_texture(t_game **game, int option, char *str)
{
    if (option < 5 || option == 7)
        case_texture(game, option,str);
    else
        case_rgb(game,option,str);
}

void validate_textures(char *str, t_game **game)
{
    int option;
    
    while(ft_isspace(*str))
        str++;
    option = texture_helper(str);
    if (option)
    {
        while(ft_isalpha(*str))
            str++;
        while(ft_isspace(*str))
            str++;
        add_texture(game, option, str);
    }
    else
    {
        error_msg("Non texture or RGB or map found.");
        free_game(game);
        exit(1);
        }
    }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   key_hook_moves.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 12:51:32 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/19 16:50:07 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

bool collision_detection(t_game *game, double new_x, double new_y)
{
    int map_x = (int)new_x;
    int map_y = (int)new_y;
    t_door *door;
    char tile;

    tile = game->map->map[map_y][map_x];
    if (map_x < 0 || map_x >= game->map->map_width || map_y < 0 || map_y >= game->map->map_height) //out of bounds
        return false;
    if (tile == '1') //hit a wall
        return false;
    else if (tile == 'D')
    {
        door = door_at(game, map_x, map_y);
        if (!door || door->frac < 0.5)
            return false;
    }
    return true;
}

void pause_screen(t_game *game)
{
    int cx;
    int cy;

    cx = WIN_WIDTH / 2;
    cy = WIN_HEIGHT / 2;
    game->game_pause = !game->game_pause;
    if (game->game_pause)
        mlx_mouse_show(game->mlx, game->win);
    else
    {
        mlx_mouse_hide(game->mlx, game->win);
        mlx_mouse_move(game->mlx, game->win, cx, cy);
        game->last_mouse_x = cx;
    }
}


int on_key_press(int keycode, t_game *game)
{
    if (game->game_pause)
        return(0);
    if (keycode == W)
        game->buttons.w = 1;
    if (keycode == S)
        game->buttons.s = 1;
    if (keycode == A)
        game->buttons.q = 1;
    if (keycode == D)
        game->buttons.d = 1;
    if (keycode == ROTATE_LEFT)
        game->buttons.rotate_left = 1;
    if (keycode == ROTATE_RIGHT)
        game->buttons.rotate_right = 1;
    if (keycode == ESCAPE_KEY)
        return close_window_x(game);
    return(0);
}

int on_key_release(int keycode, t_game *game)
{
    if (keycode == W)
        game->buttons.w = 0;
    if (keycode == S)
        game->buttons.s = 0;
    if (keycode == A)
        game->buttons.q = 0;
    if (keycode == D)
        game->buttons.d = 0;
    if (keycode == ROTATE_LEFT)
        game->buttons.rotate_left = 0;
    if (keycode == ROTATE_RIGHT)
        game->buttons.rotate_right = 0;
    if (keycode == P)
        pause_screen(game);
    if (keycode == SPACE)
        door_use(game);
    if (keycode == M)
        game->show_minimap = !game->show_minimap;
    
    return(0);
}

int key_hook(int keycode, t_game *game)
{
    // double old_dir_x;
    // double old_plane_x;
    // double rotation_speed = 0.1;
    double move_speed = 0.5;
    double new_x;
    double new_y;
    //still needs collision detection and map boundaries + speed adjustment
    
    if(keycode == W)
    {
        new_x = game->player->player_pos->x + game->player->vector_dir->x * move_speed;
        new_y = game->player->player_pos->y + game->player->vector_dir->y * move_speed;
        
        if (collision_detection(game, new_x, new_y))
        {
            game->player->player_pos->x = new_x;
            game->player->player_pos->y = new_y;
        }
    }
    if(keycode == S)
    {
        new_x = game->player->player_pos->x - game->player->vector_dir->x * move_speed;
        new_y = game->player->player_pos->y - game->player->vector_dir->y * move_speed;

        if (collision_detection(game, new_x, new_y))
        {
            game->player->player_pos->x = new_x;
            game->player->player_pos->y = new_y;
        }
    }

    if(keycode == D)
    {
        new_x = game->player->player_pos->x - game->player->vector_dir->y * move_speed;
        new_y = game->player->player_pos->y + game->player->vector_dir->x * move_speed;

        if (collision_detection(game, new_x, new_y))
        {
            game->player->player_pos->x = new_x;
            game->player->player_pos->y = new_y;

        }
    }
    if(keycode == A)
    {
        new_x = game->player->player_pos->x + game->player->vector_dir->y * move_speed;
        new_y = game->player->player_pos->y - game->player->vector_dir->x * move_speed;

        if (collision_detection(game, new_x, new_y))
        {
            game->player->player_pos->x = new_x;
            game->player->player_pos->y = new_y;
        }
    }
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 12:13:42 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/21 13:19:34 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void welcome_message(void)
{
    ft_putstr_fd("WELCOME TO CUB3D!\n", 1);
    ft_putstr_fd("Press 'ESC' to exit.\n", 1);
    ft_putstr_fd("Use 'W', 'A', 'S', 'D' to move.\n", 1);
    ft_putstr_fd("Use mouse or 'LEFT/RIGHT' to look around.\n", 1);
    ft_putstr_fd("Press 'M' to toggle ON/OFF the minimap.\n", 1);
    ft_putstr_fd("Press 'SPACE' to open and close doors.\n", 1);
    ft_putstr_fd("Press 'P' to pause.\n", 1);
}

int main(int argc, char **argv)
{
    t_game *game_data;
    char *path;

    if (argc != 2)
    {
        error_msg("Wrong amount of arguments.");
        exit(1);
    }
    if (!*(++argv))
    {
        error_msg("No path.");
        exit(1);
    }
    path = *argv;
    if (!validate_init(&game_data, path))
    {
        error_msg("Failed to initialise.\n");
        exit(1);
    }
    create_window(game_data);
    if (!game_data->win)
        return (1);
    welcome_message();
    mlx_mouse_hide(game_data->mlx, game_data->win);
    mlx_hook(game_data->win, 2, 1L<<0, on_key_press, game_data);
    mlx_hook(game_data->win, 3, 1L<<1, on_key_release,  game_data);
    mlx_hook(game_data->win, 6, 1L<<6, on_mouse_move, game_data);
    mlx_loop_hook(game_data->mlx, render_frame, game_data);
    mlx_loop(game_data->mlx);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 09:32:43 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/21 17:04:58 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

void	ft_free_string_array(char **arr)
{
        int	i;
        if (!arr)
                return ;
        i = 0;
        while (arr[i])
        {
                free(arr[i]);
                arr[i] = NULL;
                i++;
        }
        free(arr);
}

void ft_free_rgb(t_rgb *rgb)
{
    if (!rgb)
        return;
    free(rgb);
}

void ft_free_map(t_map **map)
{
    if (!map || !*map)
        return;
    ft_free_string_array((*map)->content);
    ft_free_rgb((*map)->ceiling);
    ft_free_rgb((*map)->floor);
    free(*map);
    *map = NULL;
}

void free_game(t_game **game)
{
    if (!game || !*game)
        return;
    if ((*game)->map)
        ft_free_map(&((*game)->map));
    free(*game);
    *game = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mini_dda.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 12:33:19 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/19 16:43:26 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

 int interact_cast(t_game *g)
{
    t_ray ray;
    double px;
    double py;
    int map_x;
    int map_y;
    int step_x;
    int step_y;
    double delta_x;
    double delta_y;
    double side_dist_x;
    double side_dist_y;
    int hit;
    int side;
    int tile;
    double t;
    
    px = g->player->player_pos->x;
    py = g->player->player_pos->y;
    map_x = (int)g->player->player_pos->x;
    map_y = (int)g->player->player_pos->y;
    ray.ray_dir.x = g->player->vector_dir->x;
    ray.ray_dir.y = g->player->vector_dir->y;
    if (ray.ray_dir.x == 0)
        delta_x = 1e30;
    else
        delta_x = fabs(1.0 / ray.ray_dir.x);
    if (ray.ray_dir.y == 0)
        delta_y = 1e30;
    else
        delta_y = fabs(1.0 / ray.ray_dir.y);
    if (ray.ray_dir.x < 0)
    {
        step_x = -1;
        side_dist_x = (px - map_x) * delta_x;
    }
    else
    {
        step_x = 1;
        side_dist_x = (map_x + 1.0 - px) * delta_x;
    }
    if (ray.ray_dir.y < 0)
    {
        step_y = -1;
        side_dist_y = (py - map_y) * delta_y;
    }
    else
    {
        step_y = 1;
        side_dist_y = (map_y + 1.0 - py) * delta_y;
    }
    hit = 0;
    while (hit == 0)
    {
        if (side_dist_x < side_dist_y)
        {
            side_dist_x += delta_x;
            map_x += step_x;
            side = 0;
        }
        else
        {
            side_dist_y += delta_y;
            map_y += step_y;
            side = 1;
        }
        if (map_x < 0 || map_x >= g->map->map_width || map_y < 0 || map_y >= g->map->map_height)
            return (0);
        if (g->map->map[map_y][map_x] == 'D' || g->map->map[map_y][map_x] == '1'|| g->map->map[map_y][map_x] == 'd')
            hit = 1;
    }
    if (side == 0)
        t = (map_x - px + (1.0 - step_x) / 2.0) / ray.ray_dir.x;
    else
        t = (map_y - py + (1.0 - step_y) / 2.0) / ray.ray_dir.y;
    if (t > USE_RANGE || t < 0)
        return 0;
    tile = g->map->map[map_y][map_x];
    if (tile == 'D' || tile == 'd')
    {
        set_vector(&g->map->door_pos, (double)map_x, (double)map_y);
        return (1);
    }
    else
        return (0);
}

void door_use(t_game *game)
{
    int x;
    int y;

    if(interact_cast(game))
    {
        x = (int)game->map->door_pos.x;
        y = (int)game->map->door_pos.y;
        door_toggle_at(game, x, y);
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minimap.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/12 10:27:58 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/21 16:51:14 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int is_inside_circle(int x, int y, int center_x, int center_y, int radius)
{
    int dx = x - center_x;
    int dy = y - center_y;
    return (dx * dx + dy * dy) <= (radius * radius);
}

void draw_minimap_pixel(t_game *game, int x, int y, int color)
{
    char *dst;

    if (x < 0 || x >= WIN_WIDTH || y < 0 || y >= WIN_HEIGHT)
        return;
    dst = game->addr + (y * game->line_length + x * (game->bits_per_pixel / 8));
    *(unsigned int*)dst = color;
}

void draw_minimap_pixel_circle(t_game *game, int x, int y, int color, int center_x, int center_y, int radius)
{
    char *dst;

    if (x < 0 || x >= WIN_WIDTH || y < 0 || y >= WIN_HEIGHT)
        return;
    if (!is_inside_circle(x, y, center_x, center_y, radius))
        return;
    dst = game->addr + (y * game->line_length + x * (game->bits_per_pixel / 8));
    *(unsigned int*)dst = color;
}

void draw_minimap_square_circle(t_game *game, int start_x, int start_y, int size, int color, int center_x, int center_y, int radius)
{
    int x;
    int y;

    y = start_y;
    while (y < start_y + size)
    {
        x = start_x;
        while (x < start_x + size)
        {
            draw_minimap_pixel_circle(game, x, y, color, center_x, center_y, radius);
            x++;
        }
        y++;
    }
}

void draw_circle_border(t_game *game, int center_x, int center_y, int radius, int thickness)
{
    int y = center_y - radius - thickness;
    int x;
    int distance;
    int outer_radius = radius + thickness;
    int inner_radius = radius;

    while (y <= center_y + radius + thickness)
    {
        x = center_x - radius - thickness;
        while (x <= center_x + radius + thickness)
        {
            distance = (x - center_x) * (x - center_x) + (y - center_y) * (y - center_y);
            if (distance <= outer_radius * outer_radius && distance > inner_radius * inner_radius)
                draw_minimap_pixel_circle(game, x, y, create_rgb_color(255, 255, 255), center_x, center_y, radius + thickness);
            x++;
        }
        y++;
    }
}

void draw_minimap(t_game *game)
{
    int map_x;
    int map_y;
    int screen_x;
    int screen_y;
    double player_x;
    double player_y;
    int player_screen_x;
    int player_screen_y;
    int minimap_size = 20;
    int minimap_radius = (minimap_size * MINIMAP_TILE_SIZE) / 2;
    int center_x = MINIMAP_OFFSET_X + minimap_radius;
    int center_y = MINIMAP_OFFSET_Y + minimap_radius;
    int start_map_x, start_map_y;
    int end_map_x, end_map_y;

    player_x = game->player->player_pos->x;
    player_y = game->player->player_pos->y;
    
    start_map_x = (int)player_x - minimap_size / 2;
    start_map_y = (int)player_y - minimap_size / 2;
    end_map_x = start_map_x + minimap_size;
    end_map_y = start_map_y + minimap_size;
    draw_circle_border(game, center_x, center_y, minimap_radius, 2);
    map_y = start_map_y;
    while (map_y < end_map_y)
    {
        map_x = start_map_x;
        while (map_x < end_map_x)
        {
            screen_x = MINIMAP_OFFSET_X + (map_x - start_map_x) * MINIMAP_TILE_SIZE;
            screen_y = MINIMAP_OFFSET_Y + (map_y - start_map_y) * MINIMAP_TILE_SIZE;      
            if (map_x < 0 || map_x >= game->map->map_width || 
                map_y < 0 || map_y >= game->map->map_height)
                draw_minimap_square_circle(game, screen_x, screen_y, MINIMAP_TILE_SIZE, create_rgb_color(64, 64, 64), center_x, center_y, minimap_radius);
            else if (game->map->map[map_y][map_x] == '1')
                draw_minimap_square_circle(game, screen_x, screen_y, MINIMAP_TILE_SIZE, create_rgb_color(0, 0, 0), center_x, center_y, minimap_radius);
            else if (game->map->map[map_y][map_x] == 'D' || game->map->map[map_y][map_x] == 'd')
                draw_minimap_square_circle(game, screen_x, screen_y, MINIMAP_TILE_SIZE, create_rgb_color(25, 210, 250), center_x, center_y, minimap_radius);
            else if (game->map->map[map_y][map_x] == ' ')
                draw_minimap_square_circle(game, screen_x, screen_y, MINIMAP_TILE_SIZE, create_rgb_color(128, 128, 128), center_x, center_y, minimap_radius);
            else if (game->map->map[map_y][map_x] == '0' || game->map->map[map_y][map_x] == 'N' || 
                     game->map->map[map_y][map_x] == 'S' || game->map->map[map_y][map_x] == 'E' || 
                     game->map->map[map_y][map_x] == 'W')
                draw_minimap_square_circle(game, screen_x, screen_y, MINIMAP_TILE_SIZE, create_rgb_color(200, 200, 200), center_x, center_y, minimap_radius);
            else
                draw_minimap_square_circle(game, screen_x, screen_y, MINIMAP_TILE_SIZE, create_rgb_color(128, 128, 128), center_x, center_y, minimap_radius);
            
            map_x++;
        }
        map_y++;
    }
    player_screen_x = center_x - MINIMAP_TILE_SIZE / 2;
    player_screen_y = center_y - MINIMAP_TILE_SIZE / 2;
    draw_minimap_square_circle(game, player_screen_x, player_screen_y, MINIMAP_TILE_SIZE, create_rgb_color(255, 0, 0), center_x, center_y, minimap_radius);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   miscs.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 09:19:25 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/07 13:49:01 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int ft_isspace(char c)
{
    if (!c)
        return (0);
    else if (c == ' ' || c == '\t' || c == '\v' || c == '\f' || c == 'r')
        return (1);
    return (0);
}

int ft_isblank(char *str)
{
    if (!str)
        return (0);
    int i;

    i = 0;
    while((ft_isspace(str[i])) || str[i] == '\n')
        i++;
    if ((size_t)i != (ft_strlen(str)))
        return(0);
    else
        return(1);
}

int ft_special_len(char *str, int separator)
{
    int i;
    
    i = 0;
    if (!str)
        return (i);
    while (str[i] && str[i] != separator)
        i++;
    return(i - 1);
}

char	*ft_strndup(const char *s, size_t n)
{
	size_t	i;
	char	*dup;

	i = 0;
	while (s[i] && i < n)
		i++;
	dup = (char *)malloc(sizeof(char) * (i + 1));
	if (!dup)
		return (NULL);
	i = 0;
	while (s[i] && i < n)
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

int count_strings(char **str)
{
    int i;

    if (!str || !*str)
        return (0);
    i = 0;
    while(str[i])
        i++;
    return(i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mouse_hook.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/12 14:36:27 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/14 12:00:20 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int on_mouse_move(int x, int y,void *param)
{
    t_game *game = (t_game *)param;
    int dx;
    int dy;
    double angle;
    double  old_dir_x;
    double  old_plane_x;
    int center_x;
    int center_y;

    if (game->game_pause)
    {
        game->last_mouse_x = x;
        return(0); 
    }
    center_x = WIN_WIDTH / 2;
    center_y = WIN_HEIGHT / 2;
    dx = x - center_x;
    dy = y - center_y;
    if (abs(dx) < 2 && abs(dy) < 2)
        return (0);
    if (abs(dx) >= 2)
    {
        angle = dx * game->mouse_sens;
        old_dir_x = game->player->vector_dir->x;
        game->player->vector_dir->x = game->player->vector_dir->x * cos(angle) - game->player->vector_dir->y * sin(angle);
        game->player->vector_dir->y = old_dir_x * sin(angle) + game->player->vector_dir->y * cos(angle);
        old_plane_x = game->player->camera_plane->x;
        game->player->camera_plane->x = game->player->camera_plane->x * cos(angle) - game->player->camera_plane->y * sin(angle);
        game->player->camera_plane->y = old_plane_x * sin(angle) + game->player->camera_plane->y * cos(angle);
    }
    if (abs(dy) >= 2)
    {
        game->player->pitch += -dy * game->mouse_sens * 300;
        if (game->player->pitch > WIN_HEIGHT / 3)
            game->player->pitch = WIN_HEIGHT / 3;
        if (game->player->pitch < - WIN_HEIGHT / 3)
            game->player->pitch = - WIN_HEIGHT / 3;
    }
    mlx_mouse_move(game->mlx, game->win, center_x, center_y);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   moves.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/14 11:22:53 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/19 16:44:57 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void move_forward(t_game *game)
{
    double move_speed = 0.05;
    double new_x;
    double new_y;

    new_x = game->player->player_pos->x + game->player->vector_dir->x * move_speed;
    new_y = game->player->player_pos->y + game->player->vector_dir->y * move_speed;
    if (collision_detection(game, new_x, new_y))
    {
        game->player->player_pos->x = new_x;
        game->player->player_pos->y = new_y;
    }
}

void move_backwards(t_game *game)
{
    double move_speed = 0.05;
    double new_x;
    double new_y;

    new_x = game->player->player_pos->x - game->player->vector_dir->x * move_speed;
    new_y = game->player->player_pos->y - game->player->vector_dir->y * move_speed;
    if (collision_detection(game, new_x, new_y))
    {
        game->player->player_pos->x = new_x;
        game->player->player_pos->y = new_y;
    }
}

void move_left(t_game *game)
{
    double move_speed = 0.05;
    double new_x;
    double new_y;

    new_x = game->player->player_pos->x + game->player->vector_dir->y * move_speed;
    new_y = game->player->player_pos->y - game->player->vector_dir->x * move_speed;
    if (collision_detection(game, new_x, new_y))
    {
        game->player->player_pos->x = new_x;
        game->player->player_pos->y = new_y;
    }
} 

void move_right(t_game *game)
{
    double move_speed = 0.05;
    double new_x;
    double new_y;

    new_x = game->player->player_pos->x - game->player->vector_dir->y * move_speed;
    new_y = game->player->player_pos->y + game->player->vector_dir->x * move_speed;
    if (collision_detection(game, new_x, new_y))
    {
        game->player->player_pos->x = new_x;
        game->player->player_pos->y = new_y;
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 09:32:37 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/11 13:31:15 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int validate_arg (char *str)
{
    char *extension;
    if(!str)
        return (0);
    extension = ft_strrchr(str, '.');
    if (!extension)
        return (0);
    else if ((ft_strncmp(extension, ".cub", 4) != 0) || (ft_strlen(extension) != 4))
        error_msg("Extension format not valid !");
    else
        return (1); 
    return(0);
}

int validate_map(char *path, t_game **game)
{
    if (!validate_arg(path))
        return (0);
    init_struct(game, path);
    return(1);
}

int validate_init(t_game **game, char *path)
{
    int i;
    
    i = validate_map(path, game);
    return(i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting_engine.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 14:15:42 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/19 17:47:27 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/*double ray_casting(int x, t_player player)
{
    double camera_x;
    int wall_hit = 0;

    while(x < WIN_WIDTH)
    {
        ///////////////////// RAY DIRECTION CALCULATIONS ///////////////////////
        camera_x = 2 * x / (double)WIN_WIDTH - 1; // that's 2 * 0 / 1024 - 1 = -1.0 (far left) if camera_x = 0
        
        t_ray ray;
        ray->ray_dir.x = player.dir.x + player.plane.x * camera_x; // ray direction in x ray_dir = center_direction + spread_left_right
        ray->ray_dir.y = player.dir.y + player.plane.y * camera_x;
        
        ray.map.x = (int)player.pos.x; //takes the current floating point and converts
        ray.map.y = (int)player.pos.y; //it to an integer to indicate the current tile the character is standing on

        delta.x = fabs(1 / ray->ray_dir.x); //delta x is the distance to the next vertical line
        delta.y = fabs(1 / ray->ray_dir.y); //delta y is the distance to the next horizontal line

        /////////////////// STEP DIRECTIONS CALCULATIONS //////////////////////
        t_vector side_dist;

        if(ray.ray_dir.x < 0) //left
        {
            step_dir_x = -1; //if ray direction is negative, we step left
            side_dist.x = (player.pos.x - ray.map.x) * delta.x;
            //side is the distance to hit the edge of the current tile to the left
        }
        else if (ray.ray_dir.x > 0) //right
        {
            step_dir_x = 1;
            side_dist.x = (ray.map.x + 1.0 - player.pos.x) * delta.x; 
        }
        
        if(ray.ray_dir.y < 0) //up
        {
            step_dir_y = -1;
            side_dist.y = (player.pos.y - ray.map.y) * delta.y;
        }
        else if (ray.ray_dir.y > 0) //down
        {
            step_dir_y = 1;
            side_dist.y = (ray.map.y + 1.0 - player.pos.y) * delta.y;
        }
        
        /////////////////// DDA LOOP //////////////////////
    int hit = 0;
    int side = 0;
    while (hit == 0)
    {
        if (side_dist_x < side_dist_y)
        {
            side_dist_x += delta_x;
            map_x += step_x;
            side = 0;
        }
        else
        {
            side_dist_y += delta_y;
            map_y += step_y;
            side = 1;
        }
        if (world_map[map_x][map_y] > 0)
            hit = 1;
    }

    double perp_wall_dist;
    if (side == 0)
        perp_wall_dist = (map_x - player.pos.x + (1 - step_x) / 2) / ray.ray_dir.x;
    else
        perp_wall_dist = (map_y - player.pos.y + (1 - step_y) / 2) / ray.ray_dir.y;

    printf("Column %d hit wall at distance: %f\n", x, perp_wall_dist);
    return perp_wall_dist;
}*/

double	ray_casting(int x, t_player *player, int *wall_direction,
			t_game *game, double *wall_x)
{
	double		camera_x;
	t_ray		ray;
	int			map_x;
	int			map_y;
	double		delta_x;
	double		delta_y;
	int			step_x;
	int			step_y;
	double		side_dist_x;
	double		side_dist_y;
	int			hit;
	int			side;
	double		hit_x;
	double		hit_y;
	double		perp_wall_dist;
	t_door		*door;
	char		tile;
	double		f;
	double		tdoor;
	double		xentry;
	double		yentry;
	double		px;
	double		py;
	int			sign;
	double		door_y0;
	double		door_x0;
	double		y_hit;
	double		x_hit;

	camera_x = 2.0 * (double)x / (double)WIN_WIDTH - 1.0;
	ray.ray_dir.x = player->vector_dir->x + player->camera_plane->x * camera_x;
	ray.ray_dir.y = player->vector_dir->y + player->camera_plane->y * camera_x;
	map_x = (int)player->player_pos->x;
	map_y = (int)player->player_pos->y;
	px = player->player_pos->x;
	py = player->player_pos->y;
	if (ray.ray_dir.x == 0.0)
		delta_x = 1e30;
	else
		delta_x = fabs(1.0 / ray.ray_dir.x);
	if (ray.ray_dir.y == 0.0)
		delta_y = 1e30;
	else
		delta_y = fabs(1.0 / ray.ray_dir.y);
	if (ray.ray_dir.x < 0.0)
	{
		step_x = -1;
		side_dist_x = (px - (double)map_x) * delta_x;
	}
	else
	{
		step_x = 1;
		side_dist_x = ((double)map_x + 1.0 - px) * delta_x;
	}
	if (ray.ray_dir.y < 0.0)
	{
		step_y = -1;
		side_dist_y = (py - (double)map_y) * delta_y;
	}
	else
	{
		step_y = 1;
		side_dist_y = ((double)map_y + 1.0 - py) * delta_y;
	}
	hit = 0;
	while (hit == 0)
	{
		if (side_dist_x < side_dist_y)
		{
			side_dist_x += delta_x;
			map_x += step_x;
			side = 0;
		}
		else
		{
			side_dist_y += delta_y;
			map_y += step_y;
			side = 1;
		}
		if (map_x < 0 || map_x >= game->map->map_width
			|| map_y < 0 || map_y >= game->map->map_height)
		{
			hit = 1;
			game->hit_tile = '1';
			break ;
		}
		tile = game->map->map[map_y][map_x];
		if (tile == 'D')
		{
			door = door_at(game, map_x, map_y);
			f = 0.0;
			if (door)
				f = door->frac;
			if (f >= 0.99)
				continue ;
			if (side == 0)
			{
				if (step_x > 0)
					xentry = (double)map_x;
				else
					xentry = (double)map_x + 1.0;
				tdoor = (xentry - px) / ray.ray_dir.x;
				sign = 0;
				if (map_y + 1 < game->map->map_height
					&& game->map->map[map_y + 1][map_x] == '1')
					sign = 1;
				else if (map_y - 1 >= 0
					&& game->map->map[map_y - 1][map_x] == '1')
					sign = -1;
				if (sign == 0)
				{
					if (step_x > 0)
						xentry = (double)map_x;
					else
						xentry = (double)map_x + 1.0;
					tdoor = (xentry + f * (double)step_x - px) / ray.ray_dir.x;
					if (tdoor > 0.0 && tdoor <= side_dist_y)
					{
						*wall_direction = get_wall_direction(side, step_x, step_y);
						*wall_x = py + tdoor * ray.ray_dir.y;
						*wall_x -= floor(*wall_x);
						game->side_out = 0;
						game->ray_dir.x = ray.ray_dir.x;
						game->ray_dir.y = ray.ray_dir.y;
						game->hit_tile = 'D';
						return (tdoor);
					}
				}
				else
				{
					y_hit = py + tdoor * ray.ray_dir.y;
					door_y0 = (double)map_y;
					if (sign > 0)
						door_y0 = (double)map_y + f;
					else if (sign < 0)
						door_y0 = (double)map_y - f;
					if (tdoor > 0.0 && tdoor <= side_dist_y
						&& y_hit >= door_y0 && y_hit < door_y0 + 1.0)
					{
						*wall_direction = get_wall_direction(side, step_x, step_y);
						*wall_x = y_hit - door_y0;
						game->side_out = 0;
						game->ray_dir.x = ray.ray_dir.x;
						game->ray_dir.y = ray.ray_dir.y;
						game->hit_tile = 'D';
						return (tdoor);
					}
				}
			}
			else
			{
				if (step_y > 0)
					yentry = (double)map_y;
				else
					yentry = (double)map_y + 1.0;
				tdoor = (yentry - py) / ray.ray_dir.y;
				sign = 0;
				if (map_x + 1 < game->map->map_width
					&& game->map->map[map_y][map_x + 1] == '1')
					sign = 1;
				else if (map_x - 1 >= 0
					&& game->map->map[map_y][map_x - 1] == '1')
					sign = -1;
				if (sign == 0)
				{
					if (step_y > 0)
						yentry = (double)map_y;
					else
						yentry = (double)map_y + 1.0;
					tdoor = (yentry + f * (double)step_y - py) / ray.ray_dir.y;
					if (tdoor > 0.0 && tdoor <= side_dist_x)
					{
						*wall_direction = get_wall_direction(side, step_x, step_y);
						*wall_x = px + tdoor * ray.ray_dir.x;
						*wall_x -= floor(*wall_x);
						game->side_out = 1;
						game->ray_dir.x = ray.ray_dir.x;
						game->ray_dir.y = ray.ray_dir.y;
						game->hit_tile = 'D';
						return (tdoor);
					}
				}
				else
				{
					x_hit = px + tdoor * ray.ray_dir.x;
					door_x0 = (double)map_x;
					if (sign > 0)
						door_x0 = (double)map_x + f;
					else if (sign < 0)
						door_x0 = (double)map_x - f;
					if (tdoor > 0.0 && tdoor <= side_dist_x
						&& x_hit >= door_x0 && x_hit < door_x0 + 1.0)
					{
						*wall_direction = get_wall_direction(side, step_x, step_y);
						*wall_x = x_hit - door_x0;
						game->side_out = 1;
						game->ray_dir.x = ray.ray_dir.x;
						game->ray_dir.y = ray.ray_dir.y;
						game->hit_tile = 'D';
						return (tdoor);
					}
				}
			}
		}
		else if (tile == '1')
		{
			hit = 1;
			game->hit_tile = '1';
		}
	}
	*wall_direction = get_wall_direction(side, step_x, step_y);
	if (side == 0)
		perp_wall_dist = ((double)map_x - px + (1.0 - (double)step_x) / 2.0)
			/ ray.ray_dir.x;
	else
		perp_wall_dist = ((double)map_y - py + (1.0 - (double)step_y) / 2.0)
			/ ray.ray_dir.y;
	hit_x = px + perp_wall_dist * ray.ray_dir.x;
	hit_y = py + perp_wall_dist * ray.ray_dir.y;
	if (side == 0)
		*wall_x = hit_y;
	else
		*wall_x = hit_x;
	*wall_x = *wall_x - floor(*wall_x);
	game->side_out = side;
	game->ray_dir.x = ray.ray_dir.x;
	game->ray_dir.y = ray.ray_dir.y;
	return (perp_wall_dist);
}

// wall height : line_height = (int)(WIN_HEIGHT / perp_wall_dist);

t_drawrange calculate_draw_range(double perp_wall_dist, t_game *game)
{
    t_drawrange range;

    if (perp_wall_dist <= 0)
    {
        range.start = 0;
        range.end = WIN_HEIGHT - 1;
        range.height = WIN_HEIGHT;
        return range;
    }
    // calculate the height of the wall line
    range.height = (int)(WIN_HEIGHT / perp_wall_dist);

    // calculate the start and end of the wall line
    range.start = (WIN_HEIGHT - range.height) / 2 + game->player->pitch;
    range.end = (WIN_HEIGHT + range.height) / 2 + game->player->pitch;

    return range;
}

void draw_vertical_line(t_game *game_data, int x, int start, int end, int color)
{
    int y;
    char *dst;

    if (start < 0) start = 0;
    if (end >= WIN_HEIGHT) end = WIN_HEIGHT - 1;
    if (start > end) return;
    
    y = start;
    while (y <= end)
    {
        dst = game_data->addr + (y * game_data->line_length + x * (game_data->bits_per_pixel / 8)); // frame buffer address calculation for rendering
        *(unsigned int*)dst = color; // set pixel color
        y++;
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting_engine_utils.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/12 09:51:29 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/19 11:04:06 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int is_pow2(int n)
{
    return (n > 0 && (n & ( n - 1)) == 0);
}

t_text *get_wall_text(int wall_dir, t_game **game)
{
    t_map *map;

    map = (*game)->map;
	if ((*game)->hit_tile == '1')
	{
		if (wall_dir == NORTH)
        	return(map->no);
    	else if (wall_dir == EAST)
        	return(map->ea);
    	else if (wall_dir == SOUTH)
        	return(map->so);
    	else if (wall_dir == WEST)
        	return(map->we);
	}
	else if ((*game)->hit_tile == 'D' && map->door)
		return(map->door);
    return (map->no);
}

void set_bytespp(t_game **game)
{
    t_map *map;
    
    map = (*game)->map;
    map->no->bytes_pp = map->no->bpp / 8;
    map->ea->bytes_pp = map->ea->bpp / 8;
    map->so->bytes_pp = map->so->bpp / 8;
    map->we->bytes_pp = map->we->bpp / 8;
	map->door->bytes_pp = map->door->bpp / 8;
}

static int	clampi(int v, int lo, int hi)
{
	if (v < lo)
		return (lo);
	if (v > hi)
		return (hi);
	return (v);
}

static int	compute_tex_x(t_game *g, t_text *tex)
{
	int	tx;

	tx = (int)(g->wall_x * (double)tex->width);
	if (g->side_out == 0 && g->ray_dir.x > 0)
		tx = tex->width - tx - 1;
	else if (g->side_out == 1 && g->ray_dir.y < 0)
		tx = tex->width - tx - 1;
	return (clampi(tx, 0, tex->width - 1));
}

/* draw the textured wall slice for screen column x */
void	draw_textures(t_game **game, int x, int start, int end, t_text *tex)
{
	int		lineh;
	int		tex_x;
	int		y;
	int		tex_y;
	double	step;
	double	draw_start_u;
	double	tex_pos;
	int		scr_bpp;

	/* reject fully off-screen / degenerate */
	if (end < 0 || start >= WIN_HEIGHT)
		return ;
	lineh = (*game)->range.height;
	if (lineh <= 0)
		return ;
	/* clamp to screen */
	if (start < 0)
		start = 0;
	if (end >= WIN_HEIGHT)
		end = WIN_HEIGHT - 1;
	/* horizontal mapping: wall_x -> tex_x (+ mirror fixes) */
	tex_x = compute_tex_x(*game, tex);
	/* vertical mapping: step in texture per screen pixel */
	step = (double)tex->height / (double)lineh;
	/* un-clamped top including pitch; then skip the clipped part */
	draw_start_u = -lineh / 2.0 + WIN_HEIGHT / 2.0 + (*game)->player->pitch;
	tex_pos = (start - draw_start_u) * step;
	/* precompute bytes/px for screen; textures already have bytes_pp */
	scr_bpp = (*game)->bits_per_pixel / 8;
	y = start;
	while (y <= end)
	{
		tex_y = (int)tex_pos;
		tex_y = clampi(tex_y, 0, tex->height - 1); /* clamp, don't wrap */
		*(unsigned int *)((*game)->addr + (long)y * (*game)->line_length + x * scr_bpp) = *(unsigned int *)(tex->addr + (long)tex_y * tex->sl + tex_x * tex->bytes_pp);
		tex_pos += step;
		y++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rendering.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 09:58:49 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/21 16:01:02 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

int	render_frame(void *param)
{
    t_game		*game;
    int			x;
    double		perp_dist;
    // int			color;
    t_text   *tex;
    int			wall_dir;
    int ceiling_color;
    int floor_color;
    int start;
    int end;

    game = (t_game *)param;
    game_update(game);
    if (!game->img)
    {
        game->img = mlx_new_image(game->mlx, WIN_WIDTH, WIN_HEIGHT);
        game->addr = mlx_get_data_addr(game->img,
                &game->bits_per_pixel, &game->line_length, &game->endian);
    }
    set_bytespp(&game);
    ceiling_color = create_rgb_color(game->map->ceiling->r, game->map->ceiling->g, game->map->ceiling->b);
    floor_color = create_rgb_color(game->map->floor->r, game->map->floor->g, game->map->floor->b);
    ft_memset(game->addr, 0, WIN_HEIGHT * game->line_length);
    x = 0;
    while (x < WIN_WIDTH)
    {
        perp_dist = ray_casting(x, game->player, &wall_dir, game, &game->wall_x);
        game->range = calculate_draw_range(perp_dist, game);
        start = game->range.start;
        end = game->range.end; 
        if (start < 0)
            start = 0;
        if (end >= WIN_HEIGHT)
            end = WIN_HEIGHT - 1;
        if (start > 0)
            draw_vertical_line(game, x, 0, start - 1, ceiling_color);
        tex = get_wall_text(wall_dir, &game);
        if (start <= end)
            draw_textures(&game, x, start, end, tex);
        if (end < WIN_HEIGHT - 1)
            draw_vertical_line(game, x, end + 1, WIN_HEIGHT - 1, floor_color);
        // calculate tex_x
        //color = get_wall_color(wall_dir);
        // color = get_shade_color(color, perp_dist);
        x++;
    }
    if (game->show_minimap)
        draw_minimap(game);
    draw_reticle(&game, 5, 10);
    mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
    return (0);
}

int get_wall_direction(int side, int step_x, int step_y)
{
    if (side == 0) 
    {
        if (step_x > 0)
            return EAST;
        else
            return WEST;
    }
    else
    {
        if (step_y > 0)
            return SOUTH;
        else
            return NORTH;
    }
}

int game_update(t_game *game)
{
    t_keymap keys;
    double old_dir_x;
    double old_plane_x;
    double rotation_speed = 0.1;
    
    keys = game->buttons;
    doors_update(game, 0.0);
    if (keys.w)
        move_forward(game);
    if (keys.s)
        move_backwards(game);
    if (keys.q)
        move_left(game);
    if (keys.d)
        move_right(game);
    if (keys.rotate_left)
    {
        old_dir_x = game->player->vector_dir->x;
        game->player->vector_dir->x = game->player->vector_dir->x * cos(-rotation_speed) - game->player->vector_dir->y * sin(-rotation_speed);
        game->player->vector_dir->y = old_dir_x * sin(-rotation_speed) + game->player->vector_dir->y * cos(-rotation_speed);
    
        old_plane_x = game->player->camera_plane->x;
        game->player->camera_plane->x = game->player->camera_plane->x * cos(-rotation_speed) - game->player->camera_plane->y * sin(-rotation_speed);
        game->player->camera_plane->y = old_plane_x * sin(-rotation_speed) + game->player->camera_plane->y * cos(-rotation_speed);
    }
    if (keys.rotate_right)
    {
        old_dir_x = game->player->vector_dir->x;
        game->player->vector_dir->x = game->player->vector_dir->x * cos(rotation_speed) - game->player->vector_dir->y * sin(rotation_speed);
        game->player->vector_dir->y = old_dir_x * sin(rotation_speed) + game->player->vector_dir->y * cos(rotation_speed);
    
        old_plane_x = game->player->camera_plane->x;
        game->player->camera_plane->x = game->player->camera_plane->x * cos(rotation_speed) - game->player->camera_plane->y * sin(rotation_speed);
        game->player->camera_plane->y = old_plane_x * sin(rotation_speed) + game->player->camera_plane->y * cos(rotation_speed);
    }
    return(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   reticle.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cauffret <cauffret@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 11:18:51 by cauffret          #+#    #+#             */
/*   Updated: 2025/08/19 16:14:04 by cauffret         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void draw_reticle(t_game **game, int thick, int size)
{
    int cx;
    int cy;
    int x;
    int y;
    int gap;
    int x_start;
    int x_end;
    int y_start;
    int y_end;
    
    gap = 3;
    cx = WIN_WIDTH / 2;
    cy = WIN_HEIGHT / 2;
    x_start = cx - (thick / 2);
    x_end = cx + (thick - 1) / 2;
    y_start = cy - (thick / 2);
    y_end = cy + (thick - 1) / 2;
    y = cy - size;
    if (size <= gap)
        return;
    // top half of arm
    while (y <= (cy - gap - 1))
    {
        x = x_start;
        while  (x <= x_end)
            draw_minimap_pixel((*game), x++, y ,create_rgb_color(255, 0, 0));
        y++;
    }
    // middle now
    y = y_start;
    while ( y <= y_end)
    {
        x = cx - size;
        while (x <= cx - gap - 1)
            draw_minimap_pixel((*game), x++, y ,create_rgb_color(255, 0, 0));
        x = cx + gap + 1;
        while (x  <= (cx + size))
            draw_minimap_pixel((*game), x++, y ,create_rgb_color(255, 0, 0));
        y++;
    }
    // bottom now
    y = cy + gap + 1;
    while (y <= (cy + size))
    {
        x = x_start;
        while  (x <= x_end)
            draw_minimap_pixel((*game), x++, y ,create_rgb_color(255, 0, 0));
        y++;
    }
}
double ray_cast(int x, t_player *player, t_ray *ray)
{
    double camera_x;
    double side_dist_x, side_dist_y;
    double perp_wall_dist;
    int hit = 0;
    int side;
    
    // Calculate ray position and direction
    camera_x = 2 * x / (double)WIN_WIDTH - 1; // x-coordinate in camera space
    ray->ray_dir.x = player->vector_dir.x + player->camera_plane.x * camera_x;
    ray->ray_dir.y = player->vector_dir.y + player->camera_plane.y * camera_x;
    
    // Which box of the map we're in
    ray->map_x = (int)player->player_pos.x;
    ray->map_y = (int)player->player_pos.y;
    
    // Length of ray from current position to x or y side
    ray->delta.x = fabs(1 / ray->ray_dir.x);
    ray->delta.y = fabs(1 / ray->ray_dir.y);
    
    // Calculate step and initial sideDist
    if (ray->ray_dir.x < 0)
    {
        ray->step_dir_x = -1;
        side_dist_x = (player->player_pos.x - ray->map_x) * ray->delta.x;
    }
    else
    {
        ray->step_dir_x = 1;
        side_dist_x = (ray->map_x + 1.0 - player->player_pos.x) * ray->delta.x;
    }
    if (ray->ray_dir.y < 0)
    {
        ray->step_dir_y = -1;
        side_dist_y = (player->player_pos.y - ray->map_y) * ray->delta.y;
    }
    else
    {
        ray->step_dir_y = 1;
        side_dist_y = (ray->map_y + 1.0 - player->player_pos.y) * ray->delta.y;
    }
    
    // Perform DDA
    while (hit == 0)
    {
        // Jump to next map square, either in x-direction, or in y-direction
        if (side_dist_x < side_dist_y)
        {
            side_dist_x += ray->delta.x;
            ray->map_x += ray->step_dir_x;
            side = 0;
        }
        else
        {
            side_dist_y += ray->delta.y;
            ray->map_y += ray->step_dir_y;
            side = 1;
        }
        // Check if ray has hit a wall
        // Note: You'll need to implement your map checking here
        // For now, assuming a simple condition - you should replace this with your actual map data
        if (ray->map_x < 0 || ray->map_x >= 24 || ray->map_y < 0 || ray->map_y >= 24)
            hit = 1; // Hit boundary (replace with your map checking logic)
    }
    
    // Calculate distance projected on camera direction
    if (side == 0)
        perp_wall_dist = (ray->map_x - player->player_pos.x + (1 - ray->step_dir_x) / 2) / ray->ray_dir.x;
    else
        perp_wall_dist = (ray->map_y - player->player_pos.y + (1 - ray->step_dir_y) / 2) / ray->ray_dir.y;
    
    ray->wall_hit = side;
    return (perp_wall_dist);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   window_management.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: chsauvag <chsauvag@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 12:40:22 by chsauvag          #+#    #+#             */
/*   Updated: 2025/08/21 13:19:57 by chsauvag         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void create_window(t_game *game)
{
    game->win = mlx_new_window(game->mlx, WIN_WIDTH, WIN_HEIGHT, "Cub3D");
    if(game->win == NULL)
    {
        error_msg("Failed to create a new window");
        mlx_destroy_display(game->mlx);
        free(game->mlx);
        return;
    }
    mlx_key_hook(game->win, close_window_hook, game);
    mlx_hook(game->win, 17, 0, close_window_x, game);
}

int close_window_hook(int keycode, t_game *game)
{
    if (keycode == ESCAPE_KEY)
    {
        mlx_destroy_window(game->mlx, game->win);
        mlx_destroy_display(game->mlx);
        free(game->mlx);
        exit(0);
    }
    return 0;
}

int close_window_x(t_game *game)
{
    mlx_destroy_window(game->mlx, game->win);
    mlx_destroy_display(game->mlx);
    free(game->mlx);
    exit(0);
    return (0);
}
